- [三大原则](#三大原则)
- [基础](#基础)
  - [`Action`](#action)
  - [`Reducer`](#reducer)
  - [`Store`](#store)
  - [数据流](#数据流)
- [与`React`结合](#与react结合)
  - [`react-redux`](#react-redux)
  - [使用感受](#使用感受)
# 三大原则
1. 单一数据源：整个应用的`state`被储存在一棵`object tree`中，并且这个` object tree`只存在于唯一一个`store`中。
2. `state`是只读的：唯一改变`state`的方法就是触发`action`，`action`是一个用于描述已发生事件的普通对象。
3. 使用纯函数来执行修改：为了描述`action`如何改变`state tree`，你需要编写`reducers`
# 基础
## `Action`
1. `action`
   * 是`store`数据的唯一来源
   * `action`中必须包含一个字符串字段：`type`，用于表示将要执行的动作
   * 多数情况下，`type`会被定义成字符串常量
    ```javascript
    export const TYPE = 'ADD_TODO'
    ```
2. `action`创建函数
   * 生成`action`的方法
    ```javascript
    export function addTodo(text) {
        return {type: TYPE, text}
    }
    ```
## `Reducer`
1. `state`结构
   * 在`redux`中，所有的`state`都在一个单一对象中
2. `action`处理
   * `reducer`是一个纯函数（只要入参相同，返回值就一定相同），接收旧的`state`和`action`，返回新的`state`
    ```javascript
    (previousState, action) => newState
    ```
   * 不能修改`state`
   * 遇到未知的`action`时，要原样返回`state`
3. 拆分`Reducer`
   * 每个`reducer`必须只能修改全局`state`中的某一部分
   * 每个`reducer`的`state`参数都不同，分别对应它管理的那部分`state`数据
   * 使用`combineReducers`合并`reducer`，以下两种写法等价
    ```javascript
    const todoApp = combineReducers({
        visibilityFilter,
        todos
    })
    ```
    ```javascript
    export default function todoApp(state = {}, action) {
        return {
            visibilityFilter: visibilityFilter(state.visibilityFilter, action),
            todos: todos(state.todos, action)
        }
    }
    ```
   * `combineReducers`返回一个`Reducer`对象
    ```javascript
    function combineReducers<M extends ReducersMapObject<any, any>>(reducers: M): Reducer
    ```
## `Store`
1. `Redux`应用只有一个单一的`store`
2. 当需要拆分数据处理逻辑时，你应该使用`reducer`组合而不是创建多个`store`
3. `store`职责
   * 维持`state`
   * 提供`getState()`方法获取`state`
   * 提供`dispatch(action)`方法更新 `state` 
   * 通过`subscribe(listener)`注册监听器
   * 通过`subscribe(listener)`返回的函数注销监听器
4. 创建`store`
```javascript
import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
```
5. 发起`action`：`store.dispatch(addTodo('Learn about actions'))`
## 数据流
1. <b>严格的单向数据</b>流是`Redux`架构的设计核心。
2. 数据的生命周期
   * 调用`store.dispatch(action)`
   * `store`调用`reducer`
     * `store`会把`state`及`action`传入创建`store`时的`reducer`函数
     * 如果使用`combineReducers`合并`reducer`，每个子`reducer`都会被调用
   * 根`reducer`把多个子`reducer`输出合并成一个单一的`state`树
   * `store`保存根`reducer`返回的完整`state`树
# 与`React`结合
## `react-redux`
## 使用感受
1. `redux`维护了一个全局状态(`state`)，每当有操作（`action`）发生，该状态都会发生改变
2. 状态的改变会执行监听(`dispatch`)的方法(`reducer`)，从而对使用`redux`的组件(`connect()`)进行更新
3. `react-redux`使用`Provider`标签将根组件包裹起来，并为它传递`store`
```javascript
ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
2. `store`由`createStore`创建，第一个参数是`reducer`
```javascript
const store = createStore(rootReducer)
```
3. `reducer`用于处理`action`，它接收`state`和`action`，返回一个新的`state`
4. `store`通过`context`向下传递
```javascript
function Provider(_ref) {
    ...
    return React.createElement(Context.Provider, {
    value: contextValue
    }, children);
}
```
5. `store`中包含了`redux`一系列的生命周期方法（`dispatch`、`getState`等）
6. 组件之间的通信，通过`connect`包装了一层
7. 每个组件接收到的`props`为：`state`有变化->`connect`监听到->`mapStateToProps`返回新的`props`->`mapDispatchToProps`返回新的`props`->两个`props`合并->传递给组件
8. 上述流程假定`connect`中包含两个参数：`mapStateToProps`、`mapDispatchToProps`
   * `mapStateToProps`的第一个参数为`store`中的`state`, 第二个`ownProps`为组件本身的`Props`
   * `mapDispatchToProps`第一个参数为`dispatch`, 第二个参数为组件本身的`Props`
   * 当`mapStateToProps`与`mapDispatchToProps`监听到接收的参数发生变化时, 会重新计算自身并返回
   * 如果方法只接收`state`, 当`props`发生变化, 方法不重新计算
9.  `mapDispatchToProps`通常返回一个`dispatch`方法，该方法会在组件实例中被调用，在`connect`期间不被调用
10. `dispatch`调用方法为创建`store`时传入的`reducer`