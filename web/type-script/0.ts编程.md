- [二-概述](#二-概述)
- [三-类型](#三-类型)
  - [类型](#类型)
- [四-函数](#四-函数)
  - [声明及调用函数](#声明及调用函数)
  - [多态](#多态)
- [五-类和接口](#五-类和接口)
- [六-类型进阶](#六-类型进阶)
  - [类型之间的关系](#类型之间的关系)
# 二-概述
* 创建ts工程: `npm install --save-dev typescript tslint @types/node`
* 执行tsc: `./node_modules/.bin/tsc`
* 使用node执行编译后文件: `node ./dist/index.js`
# 三-类型
* 类型层次结构
    ![](img-img-ts-programming/ts-class-hierarchical-structure.png)
* 约束类型: `变量名: 类型`
## 类型
* 别名
  * 声明别名: `type As = number`
* 交并集类型
  * 交集类型: `type C = A & B`
  * 并集类型: `type C = A | B`
* `any`: 未显式定义的类型tsc自动推断为`any`
* 基本类型
  * `unknown`: 
    * 使用受到限制, 并不能像`any`一样随意使用. 虽然是未知类型, 但必须显式注解
    * tsc无法自动推断; `any`可以自动推断
    * 可以比较
    * 在使用之前必须先证明它确实为某个类型. 使用`instanceof`或`typeof`
  * `boolean`: 
    * 可以比较和否定
    * 可以自动推断类型或值: `let b = true`; 可以明确指定类型或值: `let b: true = true // 使用了类型字面量, 即在类型中限定值`; 
  * `number`, `bigint`
    * 可以做数字运算
    * 可以自动推断或声明类型或值
    * `const`会直接将推断出值, `let`只会推断出类型
      ```
      let a = 123 // number
      const b = 567 // 567
      ```
  * `string`: 可以自动推断或声明类型或值
  * `symbol`:
    * 使用`const`声明的变量, tsc推导为`unique symbol`
    * tsc在编译时知道`unique symbol`类型的值绝不会与另一个`unique symbol`类型的值相等
* 对象
  * 如何声明对象类型
    * 生命为`object`: `let a: object`
    * 可以显式声明对象的结构: `let a: {b: number} = {b: 12}` 
    * 可以由tsc自动推断: `let a = {b: 12}` 
  * 对象遵循鸭子类型, 只要变量的结构与声明类型的结构一致即可
  * 可选属性
    * `let a: { c?: string }`: 可能有个类型为string的属性c
    * `let a: { [key: number]: boolean }`: 可能有任意多个数字属性, 类型为`boolean`
  * 索引签名`[key: T]: U`
    * 在这个对象中, 类型为`T`的键对应的值为`U`类型
    * `T`必须可以赋值给`number`或`string`
* 数组与元组
  * 数组
    * 声明数组
      ```typescript
      let a: string[] 
      let b: Array[string]  // 元组同理
      let c: readonly string[]
      let D: ReadonlyArray[string] // 元组同理
      ```
    * 类型推导: 数组离开定义的作用域后, ts将推导出一个最终类型
  * 元组
    * 定义
      * 是`数组`的子类, 是特殊的数组
      * 语法与数组相同, 支持使用`?:`创建可选元素
      * 最小长度固定, 各索引位上的值有固定的已知类型
      * 声明时必须显式声明类型
    * 声明元组
      * 固定长度: `let a: [string, string, number]`
      * 可变长度: `let b: [string, ...string]`
      * 可选元素: `let c: [number?]`
* `null`、`undefined`、`void`和`never`
  * `null`: 缺少值
  * `undefined`: 尚未定义
  * `void`: 函数没有显式返回任何值
  * `never`: 函数不返回时(抛出异常、永远执行等情况)使用的类型. 兜底类型, 可以赋给其他任何类型
* 枚举
  * 语法
    ```typescript
    enum Language { 
      English, 
      Spanish 
    }
    ```
  * 访问枚举
    ```typescript
    let a = Language.English
    let b = Language['Spanish']
    let c = Language[0]
    ```
  * 访问限制
    * `const enum`: 访问枚举值时, 只允许使用`.`的方式访问
      ```json
      {
        "complierOptions": {
          "preserveConstEnums": true
        }
      }
      ```
# 四-函数
## 声明及调用函数
* 声明函数的方法
  * 具名函数: `function greet(name: string) { return 'hello' + name }`
  * 函数表达式: `let greet2 = function(name: string) { return 'hello' + name }`
  * 箭头函数表达式: `let greet3 = (name: string) => { return 'hello' + name } // 单行函数体可以去掉括号`
  * 函数构造: `let greet4 = new Function('name', 'return "hello" + name')`
* 可选及默认参数
  * 可选参数: `function f(name?: string) {}`
  * 默认参数: `function f(name = 'Lisa') {}`
  * 剩余参数: `function f(...numbers: number[]) {}`
* 函数调用
  * 使用`()`调用
  * `apply(null, [10, 20])`: 为函数内部的this绑定一个值, 将第二个参数展开后传递给要调用的函数
  * `call(null, 10, 20)`: 与apply类型, 第二个参数不使用数组
  * `bind(null, 10, 20)()`: 返回一个可以调用的新函数, 可以在新函数上使用apply、call
* this类型: 可在函数的第一个参数中声明this类型
* 生成器函数: 返回值为`IterableIterator<>`类型
* 函数签名
  * 声明签名:
    ```typescript
    // function reserve(from, to, destination)
    // 简单版
    type Reserve = (from: Date, to: Date, destination: string) => void
    // 完整版, 支持函数重载
    type Reserve = {
      (from: Date, to: Date, destination: string): void
      (from: Date, destination: string): void
    }
    ```
  * 使用签名
    ```typescript
    // 声明了函数类型后, 参数和返回值的类型可以自动推导
    // 当函数声明重载时, 实现函数时需要完整的实现整个类型组合
    let reserve: Reserve = (from: Date, toOrDestination: Date | string, destination?: string) => {}
    ```
## 多态
* 泛型参数: 在类型层面施加约束的占位类型, 也称为多态类型参数
* 泛型声明
  * 使用尖括号`<>`声明
  * 在一对尖括号中可以声明任意个泛型参数(逗号分隔)
  * 当前作用域中相同的泛型参数最终都绑定同一个具体类型, 具体类型取决于调用时传入的参数
    ```typescript
    type Filter = {
      <T>(array: T[], f: (item: T) => boolean): T[]
    }
    ```
* 声明的位置
  * 函数: 声明在函数前, 调用函数时绑定具体类型
    ```typescript
    type Filter = {
      <T>(array: T[], f: (item: T) => boolean): T[]
    }
    // 简写
    type Filter = <T>(array: T[], f: (item: T) => boolean) => T[]
    ```
  * 类: 声明在类型名后, 实例化类时绑定具体类型
    ```typescript
    type Filter<T> = {}
    ```
  * 具名函数
    ```typescript
    function filter<T>(): T[] {}
    ```
* 泛型推导: 未指定具体类型时, T默认为{}
* 泛型别名: 只能在类型别名后声明泛型
* 泛型约束: 
  * 上界: `<T extends A>`
  * 多个约束: `<T extens A & B>`
* 泛型默认值: `<T = HTMLElement>`
# 五-类和接口
* 构造函数中带`private`的参数将自动赋给`this`
* `super`只能访问父类方法, 无法访问父类属性
* 接口`interface`
  * `type`与`interface`的异同
    * 相同点: 都可以用来定义结构, 二者可以相互赋值
    * 不同点
      * `type`更通用, 右边可以是任何类型表达式(类型、`&`、`|`等运算符); `interface`右边必须是结构
        ```typescript
        type A = number
        type B = A | string
        ```
      * 扩展接口时, 会检查子类的扩展是否与父类的类型一致
      * 同一作用域的多个同名`type`将编译失败; 同一作用域的同名`interface`将自动合并
  * `interface`声明类成员时不能带有访问符(`private`、`protected`、`public`)及`static`, 可以使用`readonly`
  * 一个类可以实现多个接口
  * 接口不生成js代码, 只存在编译时; 抽象类生成js代码
* 泛型作用域
  * 类声明的泛型可以在整个类中使用`class MyClass<K, V>`
  * 方法可以自己声明泛型
  * 静态方法不能使用类的泛型, 可以自己声明泛型
# 六-类型进阶
## 类型之间的关系
