- [二-概述](#二-概述)
- [三-类型](#三-类型)
  - [类型](#类型)
- [四-函数](#四-函数)
  - [声明及调用函数](#声明及调用函数)
  - [多态](#多态)
- [五-类和接口](#五-类和接口)
- [六-类型进阶](#六-类型进阶)
  - [类型之间的关系](#类型之间的关系)

# 二-概述

- 创建 ts 工程: `npm install --save-dev typescript tslint @types/node`
- 执行 tsc: `./node_modules/.bin/tsc`
- 使用 node 执行编译后文件: `node ./dist/index.js`

# 三-类型

- 类型层次结构
  ![](img-img-ts-programming/ts-class-hierarchical-structure.png)
- 约束类型: `变量名: 类型`

## 类型

- 别名
  - 声明别名: `type As = number`
- 交并集类型
  - 交集类型: `type C = A & B`
  - 并集类型: `type C = A | B`
- `any`: 未显式定义的类型 tsc 自动推断为`any`
- 基本类型
  - `unknown`:
    - 使用受到限制, 并不能像`any`一样随意使用. 虽然是未知类型, 但必须显式注解
    - tsc 无法自动推断; `any`可以自动推断
    - 可以比较
    - 在使用之前必须先证明它确实为某个类型. 使用`instanceof`或`typeof`
  - `boolean`:
    - 可以比较和否定
    - 可以自动推断类型或值: `let b = true`; 可以明确指定类型或值: `let b: true = true // 使用了类型字面量, 即在类型中限定值`;
  - `number`, `bigint`
    - 可以做数字运算
    - 可以自动推断或声明类型或值
    - `const`会直接将推断出值, `let`只会推断出类型
      ```
      let a = 123 // number
      const b = 567 // 567
      ```
  - `string`: 可以自动推断或声明类型或值
  - `symbol`:
    - 使用`const`声明的变量, tsc 推导为`unique symbol`
    - tsc 在编译时知道`unique symbol`类型的值绝不会与另一个`unique symbol`类型的值相等
- 对象
  - 如何声明对象类型
    - 生命为`object`: `let a: object`
    - 可以显式声明对象的结构: `let a: {b: number} = {b: 12}`
    - 可以由 tsc 自动推断: `let a = {b: 12}`
  - 对象遵循鸭子类型, 只要变量的结构与声明类型的结构一致即可
  - 可选属性
    - `let a: { c?: string }`: 可能有个类型为 string 的属性 c
    - `let a: { [key: number]: boolean }`: 可能有任意多个数字属性, 类型为`boolean`
  - 索引签名`[key: T]: U`
    - 在这个对象中, 类型为`T`的键对应的值为`U`类型
    - `T`必须可以赋值给`number`或`string`
- 数组与元组
  - 数组
    - 声明数组
      ```typescript
      let a: string[];
      let b: Array[string]; // 元组同理
      let c: readonly string[];
      let D: ReadonlyArray[string]; // 元组同理
      ```
    - 类型推导: 数组离开定义的作用域后, ts 将推导出一个最终类型
  - 元组
    - 定义
      - 是`数组`的子类, 是特殊的数组
      - 语法与数组相同, 支持使用`?:`创建可选元素
      - 最小长度固定, 各索引位上的值有固定的已知类型
      - 声明时必须显式声明类型
    - 声明元组
      - 固定长度: `let a: [string, string, number]`
      - 可变长度: `let b: [string, ...string]`
      - 可选元素: `let c: [number?]`
- `null`、`undefined`、`void`和`never`
  - `null`: 缺少值
  - `undefined`: 尚未定义
  - `void`: 函数没有显式返回任何值
  - `never`: 函数不返回时(抛出异常、永远执行等情况)使用的类型. 兜底类型, 可以赋给其他任何类型
- 枚举
  - 语法
    ```typescript
    enum Language {
      English,
      Spanish,
    }
    ```
  - 访问枚举
    ```typescript
    let a = Language.English;
    let b = Language["Spanish"];
    let c = Language[0];
    ```
  - 访问限制
    - `const enum`: 访问枚举值时, 只允许使用`.`的方式访问
      ```json
      {
        "complierOptions": {
          "preserveConstEnums": true
        }
      }
      ```

# 四-函数

## 声明及调用函数

- 声明函数的方法
  - 具名函数: `function greet(name: string) { return 'hello' + name }`
  - 函数表达式: `let greet2 = function(name: string) { return 'hello' + name }`
  - 箭头函数表达式: `let greet3 = (name: string) => { return 'hello' + name } // 单行函数体可以去掉括号`
  - 函数构造: `let greet4 = new Function('name', 'return "hello" + name')`
- 可选及默认参数
  - 可选参数: `function f(name?: string) {}`
  - 默认参数: `function f(name = 'Lisa') {}`
  - 剩余参数: `function f(...numbers: number[]) {}`
- 函数调用
  - 使用`()`调用
  - `apply(null, [10, 20])`: 为函数内部的 this 绑定一个值, 将第二个参数展开后传递给要调用的函数
  - `call(null, 10, 20)`: 与 apply 类型, 第二个参数不使用数组
  - `bind(null, 10, 20)()`: 返回一个可以调用的新函数, 可以在新函数上使用 apply、call
- this 类型: 可在函数的第一个参数中声明 this 类型
- 生成器函数: 返回值为`IterableIterator<>`类型
- 函数签名
  - 声明签名:
    ```typescript
    // function reserve(from, to, destination)
    // 简单版
    type Reserve = (from: Date, to: Date, destination: string) => void;
    // 完整版, 支持函数重载
    type Reserve = {
      (from: Date, to: Date, destination: string): void;
      (from: Date, destination: string): void;
    };
    ```
  - 使用签名
    ```typescript
    // 声明了函数类型后, 参数和返回值的类型可以自动推导
    // 当函数声明重载时, 实现函数时需要完整的实现整个类型组合
    let reserve: Reserve = (
      from: Date,
      toOrDestination: Date | string,
      destination?: string
    ) => {};
    ```

## 多态

- 泛型参数: 在类型层面施加约束的占位类型, 也称为多态类型参数
- 泛型声明
  - 使用尖括号`<>`声明
  - 在一对尖括号中可以声明任意个泛型参数(逗号分隔)
  - 当前作用域中相同的泛型参数最终都绑定同一个具体类型, 具体类型取决于调用时传入的参数
    ```typescript
    type Filter = {
      <T>(array: T[], f: (item: T) => boolean): T[];
    };
    ```
- 声明的位置
  - 函数: 声明在函数前, 调用函数时绑定具体类型
    ```typescript
    type Filter = {
      <T>(array: T[], f: (item: T) => boolean): T[];
    };
    // 简写
    type Filter = <T>(array: T[], f: (item: T) => boolean) => T[];
    ```
  - 类: 声明在类型名后, 实例化类时绑定具体类型
    ```typescript
    type Filter<T> = {};
    ```
  - 具名函数
    ```typescript
    function filter<T>(): T[] {}
    ```
- 泛型推导: 未指定具体类型时, T 默认为{}
- 泛型别名: 只能在类型别名后声明泛型
- 泛型约束:
  - 上界: `<T extends A>`
  - 多个约束: `<T extens A & B>`
- 泛型默认值: `<T = HTMLElement>`

# 五-类和接口

- 构造函数中带`private`的参数将自动赋给`this`
- `super`只能访问父类方法, 无法访问父类属性
- 接口`interface`
  - `type`与`interface`的异同
    - 相同点: 都可以用来定义结构, 二者可以相互赋值
    - 不同点
      - `type`更通用, 右边可以是任何类型表达式(类型、`&`、`|`等运算符); `interface`右边必须是结构
        ```typescript
        type A = number;
        type B = A | string;
        ```
      - 扩展接口时, 会检查子类的扩展是否与父类的类型一致
      - 同一作用域的多个同名`type`将编译失败; 同一作用域的同名`interface`将自动合并
  - `interface`声明类成员时不能带有访问符(`private`、`protected`、`public`)及`static`, 可以使用`readonly`
  - 一个类可以实现多个接口
  - 接口不生成 js 代码, 只存在编译时; 抽象类生成 js 代码
- 泛型作用域
  - 类声明的泛型可以在整个类中使用`class MyClass<K, V>`
  - 方法可以自己声明泛型
  - 静态方法不能使用类的泛型, 可以自己声明泛型

# 六-类型进阶

## 类型之间的关系
